use std::str::FromStr;
use crate::ast::{BinOp, Const, Def, Expr, ExprNode, Gate, Node, Type};
use crate::ident::{self, Ident};

grammar(int: &mut ident::Interner);

List<Sep, T>: Vec<T> = {
    <v: (<T> Sep)*> <e: T> => {
        let mut v = v;
        v.push(e);
        v
    }
}

PolyNote: Vec<(Expr, Expr, Expr)> = {
    "{" <notes: List<";", MonoNote>> "}" => notes
}

MonoNote: (Expr, Expr, Expr) = {
    <pitch: Expr> "=>" <gate: Expr> "," <vel: Expr> => {
        (pitch, gate, vel)
    }
}

Node<T>: Node<T> = { T => { Node { node: Box::new(<>) }}};

pub Expr = Node<ExprNode>;
pub ExprNode: ExprNode = {
    "fn" "(" <a: List<",", Bind>> ")" ":" <t: Type>  "=>" <e: Expr> => {
        ExprNode::Lambda(a, t, e)
    },
    "let" <i: Ident> "=" <v: Expr> "in" <e: Expr> => { ExprNode::Let(i, v, e) },
    ExprLogNode,
};

ExprLog = Node<ExprLogNode>;
ExprLogNode: ExprNode = {
    ExprLog OpLog ExprCmp => { ExprNode::BinOp(<>) },
    ExprCmpNode,
}

OpLog: BinOp = { "||" => { BinOp::Or },
                 "&&" => { BinOp::And }, }

ExprCmp: Expr = { Node<ExprCmpNode> => <> };
ExprCmpNode: ExprNode = {
    ExprCmp OpCmp ExprArith => { ExprNode::BinOp(<>) },
    ExprArithNode,
}

OpCmp: BinOp = { "==" => { BinOp::Eq },
                 "!=" => { BinOp::Neq },
                 "<=" => { BinOp::Le },
                 ">=" => { BinOp::Ge },
                 "<"  => { BinOp::Lt },
                 ">"  => { BinOp::Gt }, }

ExprArith = Node<ExprArithNode>;
ExprArithNode: ExprNode = {
    ExprArith OpArith ExprFactor => { ExprNode::BinOp(<>) },
    ExprFactorNode,
};

OpArith: BinOp = { "+" => { BinOp::Add },
                   "-" => { BinOp::Sub }, }

ExprFactor = Node<ExprFactorNode>;
ExprFactorNode: ExprNode = {
    ExprFactor OpFactor ExprTerm => { ExprNode::BinOp(<>) },
    ExprTermNode,
}

OpFactor: BinOp = { "*" => { BinOp::Mul },
                    "/" => { BinOp::Div },
                    "%" => { BinOp::Mod }, }

ExprTerm = Node<ExprTermNode>;
ExprTermNode: ExprNode = {
    Ident => { ExprNode::Var(<>) },
    Const => { ExprNode::Cst(<>) },
    <e: ExprTerm> "." <f: Ident> => { ExprNode::Field(e, f) },
    <e: ExprTerm> "[" <i: Expr> "]" => { ExprNode::Index(e, i) },
    <e: ExprTerm> "(" <a: List<",", Expr>> ")" => { ExprNode::Call(e, a) },
    "(" <e: ExprNode> ")" => e,
    "(" <n: MonoNote> ")" => { let (p, g, v) = n; ExprNode::Mono(p, g, v) },
    "{" <n: PolyNote> "}" => { ExprNode::Poly(n) }
}

Bind: (Ident, Type) = { <i: Ident> ":" <t: Type> => { (i, t) } }

Const: Const = {
    r"[0-9]+" => Const::Num(i64::from_str(<>).unwrap()),
    r#""(\\.|[^\\"])*""# => Const::Str(<>.to_string()),
    "On" => Const::Gate(Gate::On),
    "Off" => Const::Gate(Gate::Off),
    "Tie" => Const::Gate(Gate::Tie),
    "True" => Const::Bool(true),
    "False" => Const::Bool(false)
}

Type: Type = {
    "int" => Type::Int,
    "str" => Type::Str,
    "poly" => Type::Poly,
    "mono" => Type::Mono,
    "gate" => Type::Gate,
};

pub Def: Def = { "def" <v: Ident> "=" <e: Expr> => Def { name: v, value: e } }

Ident: Ident = { r"[a-zA-Z][_a-zA-Z0-9]*" => int.get(<>) }
